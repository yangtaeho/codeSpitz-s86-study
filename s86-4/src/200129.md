

Visitor
* 순수한 메모리 객체

DomVisitor
* Visitor 를 상속함.
* dom 에 대한 의존성을 먹고 있음.  
* action 을 받음 상호작용을 위해서  

Scanner  
* 


    설계란 코드의 재배치이다.  
    재배치의 이유는 역할이다.  


코드 수준에서 이 코드가 얘의 것이 아님을 알아야 적절한 위치로 코드를 이동시키는 것이 가능함.  



## 추상계층 불일치
계약이란 의존성이다.. 라고 봐도 무방함.  

Scanner 에서 constructor 에서는 자식을 받으면서
호스트 코드에서는 부모 지식을 쓰고 있다.
순수하게 Visitor 를 쓰지 않고 있음..  
이것은 문제이다.. 역할 별 분리.  

그래서 Scanner 도 추상계층을 나눠서 DomScanner 를 만든다.  

```
const Scanner  ---> visitor 와 추상화 레이어를 맞춤.
```

상속 계층 사용만 훌련하면 계속 못 만든다.  
연역적으로 만든 것에서 원리 도출하여 귀납하여 연역으로 도출한다.

못생긴 원판에서 원리를 찾아서 추상화 영역을 분리해내야 함..  



    domain pattern
    
도메인과 기능을 분리하여 도메인만 교체...

### 추상 레이어의 장점
* 새로운 니즈가 발생시 기존 추상화 계층을 상속한 새로운 구현 계층을 만들어서 대응 가능하다.  
* 구현체가 분리되서 지연 로딩이 가능함.



## 설계 종합

ViewModel

좋은 코드가 나오려면 복잡성을 인식할 수 있을 정도로 분리해야 하는데, 그게 어려움.  

옵저버에서 인포 객체는 언제나 무겁다. (ViewModelValue)
이벤트 객체 의존성이 어려움.

의존성이 단방향이면 그래도 좋은 설계임.


숨겨진 의존성  
DomScanner 와 DomVisitor 는 숨겨진 의존성을 갖고 있음.



###


나가는 선이 많으면 꺠지기 쉬움.  
들어오는 선이 많으면 무거움.  



MVVM 의 장점  
특정 구현에 대한 의존성이 적음.
가상회된 렌더링 시스템. (그래서 리엑트 네이티브가 가능한 것임)


** 널려 있는 트리 순회를 어떻게 할 것이냐를 제어문을 통해 풀어보면 좋은 연습이 될 것...(복잡한 json)

